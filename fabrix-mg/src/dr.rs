//! Dr

use async_trait::async_trait;
use bson::{doc, oid::ObjectId, to_document};
use futures::TryStreamExt;
use serde::{de::DeserializeOwned, Serialize};

use crate::{IndexOptions, MgError, MgResult, MongoBaseEc};

/// BaseCRUD trait
///
/// A Rust struct that implements this trait is a schema of MongoDB's collection.
/// According to the `crud` crate, any struct who derived `CRUD` will automatically implement this trait.
pub trait BaseCRUD {
    fn get_id(&self) -> Option<ObjectId>;

    fn remove_id(&mut self);

    fn mutate_id(&mut self, oid: ObjectId);

    /// Show `IndexOptions`, associate function.
    /// Automatically generated by `crud_derive`
    fn show_indexes() -> IndexOptions;
}

/// MongoCRUD trait
///
/// According to `crud` crate, any struct who derived `CRUD` will automatically implement this trait.
/// In other words, `MongoClient` can use methods in this trait to persist `TYPE` data.
#[async_trait]
pub trait MongoCRUD<TYPE>: MongoBaseEc
where
    TYPE: Send + Sync + Clone + Serialize + DeserializeOwned + Unpin + BaseCRUD,
{
    /// Create a new document
    async fn create<'a>(&'a self, mut value: TYPE) -> MgResult<TYPE>
    where
        TYPE: 'a,
    {
        // in case of `id` field exists, we need to remove it
        value.remove_id();
        let insert = self
            .schema::<TYPE>()?
            .insert_one(value.clone(), None)
            .await?;
        let oid = insert.inserted_id.as_object_id().unwrap();
        value.mutate_id(oid);
        Ok(value)
    }

    /// Read a document by id
    async fn read<'a>(&'a self, id: ObjectId) -> MgResult<Option<TYPE>>
    where
        TYPE: 'a,
    {
        let filter = doc! { "_id": id };
        let result = self.schema::<TYPE>()?.find_one(filter, None).await?;
        Ok(result)
    }

    /// Read many documents by ids
    async fn read_many<'a>(&'a self, ids: Vec<ObjectId>) -> MgResult<Vec<TYPE>>
    where
        TYPE: 'a,
    {
        let filter = doc! { "_id": { "$in": ids } };
        let res = self
            .schema::<TYPE>()?
            .find(filter, None)
            .await?
            .try_collect()
            .await?;

        Ok(res)
    }

    /// Read all documents
    async fn read_all<'a>(&'a self) -> MgResult<Vec<TYPE>>
    where
        TYPE: 'a,
    {
        let res = self
            .schema::<TYPE>()?
            .find(None, None)
            .await?
            .try_collect()
            .await?;

        Ok(res)
    }

    /// Update an existing document
    async fn update<'a>(&'a self, value: TYPE) -> MgResult<TYPE>
    where
        TYPE: 'a,
    {
        let oid = value.get_id().ok_or(MgError::OidNotFound)?;
        let filter = doc! {"_id": oid};
        let update = doc! {"$set": to_document(&value).unwrap()};
        self.schema::<TYPE>()?
            .update_one(filter, update, None)
            .await?;
        Ok(value)
    }

    /// Delete an existing document
    async fn delete<'a>(&'a self, id: ObjectId) -> MgResult<Option<TYPE>>
    where
        TYPE: 'a,
    {
        let filter = doc! {"_id": id};
        let result = self
            .schema::<TYPE>()?
            .find_one_and_delete(filter, None)
            .await?;
        Ok(result)
    }
}

#[cfg(test)]
mod tests {
    use serde::Deserialize;

    use super::*;
    use crate::{MongoExecutor, CRUD};

    const CONN: &str = "mongodb://root:secret@localhost:27017";
    const DB: &str = "dev";
    const CL: &str = "dev";

    #[derive(Serialize, Deserialize, Clone, Debug, CRUD)]
    struct Dev {
        pub id: Option<ObjectId>,
        pub name: String,
        pub age: i32,
    }

    #[tokio::test]
    async fn connection_success() {
        let ec = MongoExecutor::new_and_connect(CONN, DB, CL).await;

        assert!(ec.is_ok(), "connection should not fail");
    }

    #[tokio::test]
    async fn read_all_success() {
        let ec = MongoExecutor::new_and_connect(CONN, DB, CL)
            .await
            .expect("connection failed");

        let foo = ec.read_all().await;
        println!("{:?}", foo);
    }
}
